{"ast":null,"code":"/*\n * Copyright 2015-2016 the original author or authors\n * @license MIT, see LICENSE.txt for details\n *\n * @author Scott Andrews\n */\n'use strict';\n\nvar uriEncoder, operations, prefixRE;\nuriEncoder = require('./uriEncoder');\nprefixRE = /^([^:]*):([0-9]+)$/;\noperations = {\n  '': {\n    first: '',\n    separator: ',',\n    named: false,\n    empty: '',\n    encoder: uriEncoder.encode\n  },\n  '+': {\n    first: '',\n    separator: ',',\n    named: false,\n    empty: '',\n    encoder: uriEncoder.encodeURL\n  },\n  '#': {\n    first: '#',\n    separator: ',',\n    named: false,\n    empty: '',\n    encoder: uriEncoder.encodeURL\n  },\n  '.': {\n    first: '.',\n    separator: '.',\n    named: false,\n    empty: '',\n    encoder: uriEncoder.encode\n  },\n  '/': {\n    first: '/',\n    separator: '/',\n    named: false,\n    empty: '',\n    encoder: uriEncoder.encode\n  },\n  ';': {\n    first: ';',\n    separator: ';',\n    named: true,\n    empty: '',\n    encoder: uriEncoder.encode\n  },\n  '?': {\n    first: '?',\n    separator: '&',\n    named: true,\n    empty: '=',\n    encoder: uriEncoder.encode\n  },\n  '&': {\n    first: '&',\n    separator: '&',\n    named: true,\n    empty: '=',\n    encoder: uriEncoder.encode\n  },\n  '=': {\n    reserved: true\n  },\n  ',': {\n    reserved: true\n  },\n  '!': {\n    reserved: true\n  },\n  '@': {\n    reserved: true\n  },\n  '|': {\n    reserved: true\n  }\n};\n\nfunction apply(operation, expression, params) {\n  /*jshint maxcomplexity:11 */\n  return expression.split(',').reduce(function (result, variable) {\n    var opts, value;\n    opts = {};\n\n    if (variable.slice(-1) === '*') {\n      variable = variable.slice(0, -1);\n      opts.explode = true;\n    }\n\n    if (prefixRE.test(variable)) {\n      var prefix = prefixRE.exec(variable);\n      variable = prefix[1];\n      opts.maxLength = parseInt(prefix[2]);\n    }\n\n    variable = uriEncoder.decode(variable);\n    value = params[variable];\n\n    if (value === void 0 || value === null) {\n      return result;\n    }\n\n    if (Array.isArray(value)) {\n      result = value.reduce(function (result, value) {\n        if (result.length) {\n          result += opts.explode ? operation.separator : ',';\n\n          if (operation.named && opts.explode) {\n            result += operation.encoder(variable);\n            result += value.length ? '=' : operation.empty;\n          }\n        } else {\n          result += operation.first;\n\n          if (operation.named) {\n            result += operation.encoder(variable);\n            result += value.length ? '=' : operation.empty;\n          }\n        }\n\n        result += operation.encoder(value);\n        return result;\n      }, result);\n    } else if (typeof value === 'object') {\n      result = Object.keys(value).reduce(function (result, name) {\n        if (result.length) {\n          result += opts.explode ? operation.separator : ',';\n        } else {\n          result += operation.first;\n\n          if (operation.named && !opts.explode) {\n            result += operation.encoder(variable);\n            result += value[name].length ? '=' : operation.empty;\n          }\n        }\n\n        result += operation.encoder(name);\n        result += opts.explode ? '=' : ',';\n        result += operation.encoder(value[name]);\n        return result;\n      }, result);\n    } else {\n      value = String(value);\n\n      if (opts.maxLength) {\n        value = value.slice(0, opts.maxLength);\n      }\n\n      result += result.length ? operation.separator : operation.first;\n\n      if (operation.named) {\n        result += operation.encoder(variable);\n        result += value.length ? '=' : operation.empty;\n      }\n\n      result += operation.encoder(value);\n    }\n\n    return result;\n  }, '');\n}\n\nfunction expandExpression(expression, params) {\n  var operation;\n  operation = operations[expression.slice(0, 1)];\n\n  if (operation) {\n    expression = expression.slice(1);\n  } else {\n    operation = operations[''];\n  }\n\n  if (operation.reserved) {\n    throw new Error('Reserved expression operations are not supported');\n  }\n\n  return apply(operation, expression, params);\n}\n\nfunction expandTemplate(template, params) {\n  var start, end, uri;\n  uri = '';\n  end = 0;\n\n  while (true) {\n    start = template.indexOf('{', end);\n\n    if (start === -1) {\n      // no more expressions\n      uri += template.slice(end);\n      break;\n    }\n\n    uri += template.slice(end, start);\n    end = template.indexOf('}', start) + 1;\n    uri += expandExpression(template.slice(start + 1, end - 1), params);\n  }\n\n  return uri;\n}\n\nmodule.exports = {\n  /**\n   * Expand a URI Template with parameters to form a URI.\n   *\n   * Full implementation (level 4) of rfc6570.\n   * @see https://tools.ietf.org/html/rfc6570\n   *\n   * @param {string} template URI template\n   * @param {Object} [params] params to apply to the template durring expantion\n   * @returns {string} expanded URI\n   */\n  expand: expandTemplate\n};","map":null,"metadata":{},"sourceType":"script"}